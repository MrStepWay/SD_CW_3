## Архитектура системы

Система состоит из трех основных сервисов, двух баз данных и брокера сообщений.

1. **API Gateway**: Единая точка входа для всех клиентских запросов. Отвечает за маршрутизацию запросов к соответствующим микросервисам. Реализован на FastAPI и предоставляет единую OpenAPI (Swagger) документацию.
2. **Orders Service**: Отвечает за всю бизнес-логику, связанную с заказами: создание, просмотр списка и статуса. Инициирует процесс оплаты, отправляя событие в очередь.
3. **Payments Service**: Отвечает за управление счетами пользователей и обработку платежей. Создает и пополняет счета, списывает средства по запросам из очереди.
4. **PostgreSQL**: Каждый сервис (`Orders` и `Payments`) имеет собственную, изолированную базу данных PostgreSQL.
5. **RabbitMQ**: Брокер сообщений, который обеспечивает асинхронное взаимодействие между сервисами. Все межсервисные коммуникации происходят исключительно через него.

## Паттерны

Позволяют обеспечить exactly-once семантику.

### Transactional Outbox

1. В рамках одной транзакции базы данных сервис выполняет две операции:
    * Сохраняет основную бизнес-сущность (например, `Order` в таблицу `orders`).
    * Сохраняет событие для отправки в специальную таблицу `outbox_messages`.
2. Отдельный фоновый процесс (в нашем случае, `OutboxPublisher`) периодически опрашивает таблицу `outbox_messages` на наличие неопубликованных сообщений (`is_published = false`).
3. `OutboxPublisher` отправляет найденные сообщения в RabbitMQ. Только после успешного подтверждения от брокера он обновляет запись в таблице, помечая ее как опубликованную (`is_published = true`).


### Transactional Inbox

1. В `Payments Service` вся логика обработки входящего сообщения обернута в одну транзакцию базы данных.
2. Проверка на дубликат:
    * Сервис пытается вставить ID входящего сообщения (`message_id`) в специальную таблицу `inbox_messages`, у которой на этом поле стоит `PRIMARY KEY`.
    * Если вставка проходит успешно — это новое сообщение.
    * Если возникает ошибка `IntegrityError` — это дубликат. Транзакция откатывается, и сообщение игнорируется.
3. Если сообщение новое, сервис выполняет всю необходимую бизнес-логику.
4. В конце транзакция фиксируется, атомарно сохраняя и запись в `inbox_messages`, и результат выполнения бизнес-логики.


## Запуск проекта

### 1. Конфигурация

Файл `.env` содержит все необходимые переменные окружения для подключения к базам данных и RabbitMQ.

```env
# PostgreSQL Settings for Payments Service
DB_PAYMENTS__USER=user
DB_PAYMENTS__PASSWORD=password
DB_PAYMENTS__NAME=payments_db

# PostgreSQL Settings for Orders Service
DB_ORDERS__USER=user
DB_ORDERS__PASSWORD=password
DB_ORDERS__NAME=orders_db

# RabbitMQ Settings
RABBITMQ__USER=guest
RABBITMQ__PASSWORD=guest

# API Gateway Settings
ORDERS_SERVICE_URL=http://orders_service:8000
PAYMENTS_SERVICE_URL=http://payments_service:8000
```

### 3. Сборка и запуск

Выполните команду в корневой директории проекта:

```bash
docker-compose up --build -d
```

### 4. Доступ к сервисам

* **API Gateway (Swagger UI)**: `http://localhost:8000/docs`
    * Здесь находится полная Swagger (OpenAPI) документация для всех эндпоинтов системы.
* **RabbitMQ Management UI**: `http://localhost:15672`
    * Логин/пароль: `guest`/`guest`. Можно наблюдать за очередями и сообщениями.ы

## Спецификация API

Все эндпоинты доступны через **API Gateway** (`http://localhost:8000`). Вся документация также доступна по адресу `http://localhost:8000/docs`.

### Payments Service

Сервис отвечает за управление счетами и балансами пользователей.

---

#### `POST /v1/accounts`

Создает новый счет для указанного пользователя с нулевым балансом.

**Тело запроса:**
```json
{
  "user_id": 101
}
```

**Успешный ответ (201 Created):**
```json
{
  "id": 1,
  "user_id": 101,
  "balance": "0.00"
}
```

**Возможные ошибки:**
*   `409 Conflict`: Если счет для данного `user_id` уже существует.

---

#### `POST /v1/accounts/deposit`

Пополняет баланс существующего счета пользователя.

**Тело запроса:**
```json
{
  "user_id": 101,
  "amount": "500.00"
}
```

**Успешный ответ (200 OK):**
```json
{
  "id": 1,
  "user_id": 101,
  "balance": "500.00"
}
```

**Возможные ошибки:**
*   `404 Not Found`: Если счет для данного `user_id` не найден.

---

#### `GET /v1/accounts/{user_id}`

Возвращает информацию о счете и текущий баланс пользователя.

**Параметры пути:**
*   `user_id` (integer): Уникальный идентификатор пользователя.

**Успешный ответ (200 OK):**
```json
{
  "id": 1,
  "user_id": 101,
  "balance": "350.00"
}
```

**Возможные ошибки:**
*   `404 Not Found`: Если счет для данного `user_id` не найден.

---

### Orders Service

Сервис отвечает за создание заказов и отслеживание их статуса.

---

#### `POST /v1/orders/`

Создает новый заказ. Инициирует асинхронный процесс оплаты.

**Тело запроса:**
```json
{
  "user_id": 101,
  "amount": "150.00",
  "description": "хз"
}
```

**Успешный ответ (201 Created):**
*Возвращается сразу после создания заказа, до завершения оплаты.*
```json
{
  "id": 123,
  "user_id": 101,
  "amount": "150.00",
  "description": "хз",
  "status": "NEW"
}
```

---

#### `GET /v1/orders/`

Возвращает список всех заказов для указанного пользователя.

**Параметры запроса:**
*   `user_id` (integer, **обязательный**): Уникальный идентификатор пользователя.

**Успешный ответ (200 OK):**
```json
[
  {
    "id": 124,
    "user_id": 101,
    "amount": "25.50",
    "description": "хз1",
    "status": "CANCELLED"
  },
  {
    "id": 123,
    "user_id": 101,
    "amount": "150.00",
    "description": "хз2",
    "status": "FINISHED"
  }
]
```

---

#### `GET /v1/orders/{order_id}`

Возвращает информацию и текущий статус конкретного заказа.

**Параметры пути:**
*   `order_id` (integer): Уникальный идентификатор заказа.

**Параметры запроса:**
*   `user_id` (integer, **обязательный**): Уникальный идентификатор пользователя, которому принадлежит заказ.

**Успешный ответ (200 OK):**
```json
{
  "id": 123,
  "user_id": 101,
  "amount": "150.00",
  "description": "хз",
  "status": "FINISHED"
}
```

**Возможные ошибки:**
*   `404 Not Found`: Если заказ с указанным `order_id` не найден или не принадлежит данному `user_id`.
